diff --git a/drivers/hwspinlock/rcar_hwspinlock.c b/drivers/hwspinlock/rcar_hwspinlock.c
old mode 100644
new mode 100755
index 8b45c49..121a4bb
--- a/drivers/hwspinlock/rcar_hwspinlock.c
+++ b/drivers/hwspinlock/rcar_hwspinlock.c
@@ -12,6 +12,10 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  */
+ 
+/******************************************************************************************
+ * Includes
+ ******************************************************************************************/
 #include <linux/hwspinlock.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -22,14 +26,483 @@
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/sys_soc.h>
-
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/irqreturn.h>
+#include <linux/interrupt.h>
+#include <asm/siginfo.h>
+#include <linux/pid_namespace.h>
+#include <linux/pid.h>
+#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include "hwspinlock_internal.h"
 
+/******************************************************************************************
+ * Definitions
+ ******************************************************************************************/
 #define MFISLCKR0_OFFSET	0x000000C0
 #define MFISLCKR8_OFFSET	0x00000724
 #define MFISLCKR_NUM_8		8	/* r8a7795 ES1.*, r8a7796 ES1.* */
 #define MFISLCKR_NUM_64		64
 
+/* communication registers CONTROL */
+#define MFISARIICR0_OFFSET	0x00000400 
+#define MFISAREICR0_OFFSET  0x00000404
+#define MFISAREICR1_OFFSET  0x0000040C
+/* communication registers MESSAGE */
+#define MFISARIMBR0_OFFSET	0x00000440 
+
+/* MFIS number of message register */
+#define MFIS_MSG_SIZE   8
+
+/* IOCTL definitions */
+#define WR_VALUE _IOW ('a', 1, int32_t*)
+#define RD_VALUE _IOR ('a', 2, int32_t*)
+
+/* Device file definitions */
+#define NB_IOCTL_FILE   1
+#define NB_CAM_FILE     8
+#define NB_DEVICE_FILE   (NB_IOCTL_FILE + NB_CAM_FILE)
+
+/* IRQ parsing definitions */
+#define MFIS_GET_IRQ_TYPE(x)            ((x & 0x6000) >> 13)
+#define MFIS_SET_IRQ_TYPE(x, type)      (x = ((x & 0x8FFF) | (type << 13)))
+#define MFIS_GET_IRQ_CAM_FRAME(x)       ((x & 0x000E) >> 1)
+
+#define MFIS_IRQ_CONFIG             0x0
+#define MFIS_IRQ_CAM_FRAME          0x1
+
+/* Others */
+#define ASCII_OFFSET        48
+
+/******************************************************************************************
+ * Global variables
+ ******************************************************************************************/
+/* IOCTL global variables */
+static dev_t dev;
+static struct cdev c_dev[NB_DEVICE_FILE];
+static struct class *cl;
+
+/* MFIS communication variables */
+static u32 __iomem *base_addr; /* Base address of peripheral */
+static int32_t val_read[MFIS_MSG_SIZE];
+static int message_received = 0;
+char cam_last_frame[NB_CAM_FILE];
+char cam_irq_count[NB_CAM_FILE];
+
+/* Wait Queues */
+struct wait_queue_head wait_queue_cam_it[NB_CAM_FILE];
+static char wait_queue_cam_flag[NB_CAM_FILE];
+struct wait_queue_head wait_queue_config_it;
+static char wait_queue_config_flag;
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_send_msg_config
+ *
+ * Purpose: Write message in MFIS message registers and raise IRQ_1 for R7
+ *
+ * Input Parameters: - int32_t* val: array of val to send to R7
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static void mfis_send_msg_config(int32_t* val)
+{
+    int i;
+	void *addr;
+
+	/* Fill 8 message registers */
+    for(i=0; i<MFIS_MSG_SIZE; i++)
+    {
+        addr = (void __force *)base_addr + MFISARIMBR0_OFFSET + sizeof(u32) * i * 2;
+        iowrite32(val[i], (void __iomem *)addr);
+    }
+    
+    /* Send IRQ 1 to R7 */
+    addr = (void __force *)base_addr + MFISARIICR0_OFFSET;
+    iowrite32(1, (void __iomem *)addr);
+}
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_get_msg_config
+ *
+ * Purpose: Copy MFIS message registers in rx buffer and raise flag
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static void mfis_get_msg_config(void)
+{
+    int i;
+	void *addr;
+
+	/* Get 8 message registers */
+    for(i=0; i<MFIS_MSG_SIZE; i++)
+    {
+        addr = (void __force *)base_addr + MFISARIMBR0_OFFSET + sizeof(u32) + sizeof(u32) * i * 2;
+        val_read[i] = (uint32_t) ioread32((void __iomem *)addr);
+    }
+    
+    if(wait_queue_config_flag != -1)
+    {
+        wait_queue_config_flag = 1;
+        wake_up_interruptible(&wait_queue_config_it);
+    }
+    
+    message_received = 1;
+}
+
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_unlock_cam_read
+ *
+ * Purpose: Unlock the camera read() working queues
+ *
+ * Input Parameters: - int cam_id : camera ID to unlock
+ *                   - uint32_t irq_reg : irq register to parse
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static void mfis_unlock_cam_read(int cam_id, uint32_t irq_reg)
+{
+    /* Update ID of the last frame received and increase IRQ couonter*/
+    cam_last_frame[cam_id] = (char)(MFIS_GET_IRQ_CAM_FRAME(irq_reg));
+    cam_irq_count[cam_id] ++;
+    
+    wait_queue_cam_flag[cam_id] = 1;
+    wake_up_interruptible(&wait_queue_cam_it[cam_id]);
+}
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_clear_irq
+ *
+ * Purpose: Clear IRQ from R7
+ *
+ * Input Parameters: - int irq_id : IRQ ID to clear
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static void mfis_clear_irq(int irq_id)
+{
+	void *addr;
+
+    /* Clear IRQ from R7 */
+    addr = (void __force *)base_addr + MFISAREICR0_OFFSET + (sizeof(u32) * irq_id * 2);
+    iowrite32(0, (void __iomem *)addr);
+}
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_handle_irq
+ *
+ * Purpose: Handle all IRQs from R7
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static void mfis_handle_irq(int irq_id)
+{
+	void *addr;
+	uint32_t irq_reg;
+	
+    /* Read IRQ register */
+    addr = (void __force *)base_addr + MFISAREICR0_OFFSET + (sizeof(u32) * irq_id * 2);
+	irq_reg = (uint32_t) ioread32((void __iomem *)addr);
+	
+	/* Parse and handle IRQ */
+	switch (MFIS_GET_IRQ_TYPE(irq_reg)) {
+        
+        case MFIS_IRQ_CONFIG:
+            /* New config message received : copy it in RX buffer */
+            mfis_get_msg_config();
+        break;
+
+        case MFIS_IRQ_CAM_FRAME:
+            /* New camera frame received : unlock the read() */
+            mfis_unlock_cam_read(irq_id, irq_reg);
+        break;
+
+        default:
+        break;
+    }
+
+    /* Clear IRQ */
+    mfis_clear_irq(irq_id);
+}
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_check_R7_irq_state
+ *
+ * Purpose:
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static int mfis_check_R7_irq_state(void)
+{
+	void *addr;
+    
+    /* Return IRQ state on R7 side (if 1 it means IRQ has not been handled by R7) */
+    addr = (void __force *)base_addr + MFISARIICR0_OFFSET;
+    return (int) ioread32((void __iomem *)addr);
+}
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_irq_handlerX
+ *
+ * Purpose: MFIS IRQ handlers
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static irqreturn_t mfis_irq_handler0(int irq, void * ident)
+{
+    mfis_handle_irq(0);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t mfis_irq_handler1(int irq, void * ident)
+{
+    mfis_handle_irq(1);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t mfis_irq_handler2(int irq, void * ident)
+{
+    mfis_handle_irq(2);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t mfis_irq_handler3(int irq, void * ident)
+{
+    mfis_handle_irq(3);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t mfis_irq_handler4(int irq, void * ident)
+{
+    mfis_handle_irq(4);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t mfis_irq_handler5(int irq, void * ident)
+{
+    mfis_handle_irq(5);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t mfis_irq_handler6(int irq, void * ident)
+{
+    mfis_handle_irq(6);
+    return IRQ_HANDLED;
+}
+static irqreturn_t mfis_irq_handler7(int irq, void * ident)
+{
+    mfis_handle_irq(7);
+    return IRQ_HANDLED;
+}
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_config_open/close
+ *
+ * Purpose:
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static int mfis_config_open(struct inode *i, struct file *f)
+{
+    wait_queue_config_flag = 0;
+    return 0;
+}
+static int mfis_config_close(struct inode *i, struct file *f)
+{
+    wait_queue_config_flag = -1;
+    return 0;
+}
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_config_ioctl
+ *
+ * Purpose: Handle IOCTL handler
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static long mfis_config_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
+{
+    int32_t val_write[MFIS_MSG_SIZE];
+    
+    switch (cmd)
+    {
+        case WR_VALUE:
+            /* Get message from user space */
+            if (copy_from_user(val_write, (int32_t *)arg, sizeof(val_write)))
+            {
+                return -EACCES;
+            }
+
+            /* Cannot write new message, previous one still pending */
+            if(mfis_check_R7_irq_state())
+            {
+                return -EBUSY;
+            }
+
+            /* Send message to R7 */
+            mfis_send_msg_config(val_write);
+            
+            break;
+        case RD_VALUE:
+            /* Wait for IRQ from R7 */
+            wait_event_interruptible(wait_queue_config_it, wait_queue_config_flag);
+            wait_queue_config_flag = 0;
+            
+            /* Send message to user space */
+            if (copy_to_user((int32_t *)arg, val_read, sizeof(val_read)))
+            {
+                return -EACCES;
+            }
+            message_received = 0;
+            
+            break;
+        default:
+            return -EINVAL;
+    }
+ 
+    return 0;
+}
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_cam_open/close
+ *
+ * Purpose:
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static int mfis_cam_open(struct inode *i, struct file *f)
+{
+    return 0;
+}
+static int mfis_cam_close(struct inode *i, struct file *f)
+{
+    return 0;
+}
+
+/******************************************************************************************
+ *
+ * Function Name: mfis_cam_read
+ *
+ * Purpose:
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static ssize_t mfis_cam_read(struct file *filep, char *buffer, size_t len, loff_t *offset)
+{
+    /* file iminor is used to determine wich cam file is called.
+       The cam file numbers start at 0. It is defined in the probe fct */
+    int cam_read_id = iminor(filep->f_inode);
+    char tx_buff[2];
+     
+    wait_event_interruptible(wait_queue_cam_it[cam_read_id], wait_queue_cam_flag[cam_read_id]);
+    wait_queue_cam_flag[cam_read_id] = 0;
+    
+    /* Prepare TX buffer with last cam ID and number of IRQ since last read */
+    tx_buff[0] = cam_last_frame[cam_read_id];
+    tx_buff[1] = cam_irq_count[cam_read_id];
+    cam_irq_count[cam_read_id] = 0;
+    
+    if (copy_to_user(buffer, &tx_buff, 2))
+    {
+        return -EACCES;
+    }
+    return 1;
+}
+
+/***********************************************************************************************************************
+* File operations structure
+***********************************************************************************************************************/
+static struct file_operations mfis_fops =
+{
+    .owner = THIS_MODULE,
+    .open = mfis_config_open,
+    .release = mfis_config_close,
+    .unlocked_ioctl = mfis_config_ioctl
+};
+
+static struct file_operations mfis_cam_fops =
+{
+    .owner = THIS_MODULE,
+    .open = mfis_cam_open,
+    .release = mfis_cam_close,
+    .read = mfis_cam_read
+};
+
+/******************************************************************************************
+ *
+ * Function Name: rcar_hwspinlock_trylock/unlock
+ *
+ * Purpose:
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
 static int rcar_hwspinlock_trylock(struct hwspinlock *lock)
 {
 	void *addr = lock->priv;
@@ -61,6 +534,19 @@ static const struct of_device_id rcar_hwspinlock_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, rcar_hwspinlock_of_match);
 
+/******************************************************************************************
+ *
+ * Function Name: rcar_hwspinlock_probe
+ *
+ * Purpose: Driver probe
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
 static int rcar_hwspinlock_probe(struct platform_device *pdev)
 {
 	int				ch;
@@ -69,7 +555,10 @@ static int rcar_hwspinlock_probe(struct platform_device *pdev)
 	u32 __iomem			*addr;
 	struct resource			*res;
 	struct hwspinlock_device	*bank;
-
+    struct device *dev_ret;
+    int irq;
+    int i;
+    
 	/* allocate hwspinlock control info */
 	bank = devm_kzalloc(&pdev->dev, sizeof(*bank)
 			    + sizeof(struct hwspinlock) * MFISLCKR_NUM_64,
@@ -86,12 +575,16 @@ static int rcar_hwspinlock_probe(struct platform_device *pdev)
 	addr = (u32 __iomem *)devm_ioremap_nocache(&pdev->dev,
 						   res->start,
 						   resource_size(res));
+						   
 	if (!addr) {
 		dev_err(&pdev->dev, "Failed to remap register.\n");
 		ret = PTR_ERR(addr);
 		goto out;
 	}
 
+    /* Store base address */
+    base_addr = addr;
+    
 	/* create lock for MFISLCKR0-7 */
 	for (ch = 0; ch < 8; ch++)
 		bank->lock[ch].priv = (void __force *)addr + MFISLCKR0_OFFSET
@@ -118,11 +611,168 @@ static int rcar_hwspinlock_probe(struct platform_device *pdev)
 				   0, num_locks);
 	if (ret)
 		pm_runtime_disable(&pdev->dev);
-
+		
+	/* ----- Register file device to system ---- */
+	
+	/* Allocate file number for all devices */
+	ret = alloc_chrdev_region(&dev, 0, NB_DEVICE_FILE, "mfis_api");
+    if (ret < 0)
+    {
+        dev_err(&pdev->dev, "cannot allocate major number \n");
+        return ret;
+    }
+    
+    /* Create class for the devices */
+    cl = class_create(THIS_MODULE, "mfis_class");
+    if (IS_ERR(cl))
+    {
+        ret = PTR_ERR(cl);
+        goto destroy_device_class;
+    }
+    
+    /* Init cdev for CAM devices */
+    for(i=0; i<NB_CAM_FILE; i++)
+    {
+        cdev_init(&c_dev[i], &mfis_cam_fops);
+        ret = cdev_add(&c_dev[i], MKDEV(MAJOR(dev), MINOR(dev) + i), 1);
+        if (ret < 0)
+        {
+            dev_err(&pdev->dev, "cannot add device to system \n");
+            goto destroy_device_class;
+        }
+    }
+    
+    /* Init cdev for IOCTL device */
+    cdev_init(&c_dev[NB_CAM_FILE], &mfis_fops);
+    ret = cdev_add(&c_dev[NB_CAM_FILE], MKDEV(MAJOR(dev), MINOR(dev) + NB_DEVICE_FILE -1), 1);
+    if (ret < 0)
+    {
+        dev_err(&pdev->dev, "cannot add device to system \n");
+        goto unregister_char_device;
+    }
+    
+    /* Create camera devices */
+    for(i=0; i<NB_CAM_FILE; i++)
+    {
+        dev_ret = device_create(cl, NULL, MKDEV(MAJOR(dev), MINOR(dev) + i), NULL, "mfis_cam%d", i);
+        if (IS_ERR(dev_ret))
+        {
+            dev_err(&pdev->dev, "cannot create file device \n");
+            ret = PTR_ERR(dev_ret);
+            goto delete_cdev;
+        }
+    }
+    
+    /* Create IOCTL device */
+    dev_ret = device_create(cl, NULL, MKDEV(MAJOR(dev), MINOR(dev) + NB_DEVICE_FILE -1), NULL, "mfis_ioctl");
+    if (IS_ERR(dev_ret))
+    {
+        dev_err(&pdev->dev, "cannot create file device \n");
+        ret = PTR_ERR(dev_ret);
+        goto delete_cdev;
+    }
+    
+    /* ----- Register IRQs ----- */
+    
+    irq = platform_get_irq(pdev, 0);
+    if((ret = request_irq(irq, mfis_irq_handler0, IRQF_SHARED, "mfis_irq0", THIS_MODULE->name)) != 0)
+    {
+        dev_err(&pdev->dev, "cannot register mfis irq %d \n", irq);
+        goto irq_error;
+    }
+    
+    irq = platform_get_irq(pdev, 1);
+    if((ret = request_irq(irq, mfis_irq_handler1, IRQF_SHARED, "mfis_irq1", THIS_MODULE->name)) != 0)
+    {
+        dev_err(&pdev->dev, "cannot register mfis irq %d \n", irq);
+        goto irq_error;
+    }
+    
+    irq = platform_get_irq(pdev, 2);
+    if((ret = request_irq(irq, mfis_irq_handler2, IRQF_SHARED, "mfis_irq2", THIS_MODULE->name)) != 0)
+    {
+        dev_err(&pdev->dev, "cannot register mfis irq %d \n", irq);
+        goto irq_error;
+    }
+    
+    irq = platform_get_irq(pdev, 3);
+    if((ret = request_irq(irq, mfis_irq_handler3, IRQF_SHARED, "mfis_irq3", THIS_MODULE->name)) != 0)
+    {
+        dev_err(&pdev->dev, "cannot register mfis irq %d \n", irq);
+        goto irq_error;
+    }
+    
+    irq = platform_get_irq(pdev, 4);
+    if((ret = request_irq(irq, mfis_irq_handler4, IRQF_SHARED, "mfis_irq4", THIS_MODULE->name)) != 0)
+    {
+        dev_err(&pdev->dev, "cannot register mfis irq %d \n", irq);
+        goto irq_error;
+    }
+    
+    irq = platform_get_irq(pdev, 5);
+    if((ret = request_irq(irq, mfis_irq_handler5, IRQF_SHARED, "mfis_irq5", THIS_MODULE->name)) != 0)
+    {
+        dev_err(&pdev->dev, "cannot register mfis irq %d \n", irq);
+        goto irq_error;
+    }
+    
+    irq = platform_get_irq(pdev, 6);
+    if((ret = request_irq(irq, mfis_irq_handler6, IRQF_SHARED, "mfis_irq6", THIS_MODULE->name)) != 0)
+    {
+        dev_err(&pdev->dev, "cannot register mfis irq %d \n", irq);
+        goto irq_error;
+    }
+    
+    irq = platform_get_irq(pdev, 7);
+    if((ret = request_irq(irq, mfis_irq_handler7, IRQF_SHARED, "mfis_irq7", THIS_MODULE->name)) != 0)
+    {
+        dev_err(&pdev->dev, "cannot register mfis irq %d \n", irq);
+        goto irq_error;
+    }
+    
+    /* Init variables */
+    message_received = 0;
+    
+    for(i=0; i<NB_CAM_FILE; i++)
+	{
+        init_waitqueue_head(&wait_queue_cam_it[i]);
+    }
+    
+    init_waitqueue_head(&wait_queue_config_it);
+    
 out:
 	return ret;
+	
+	/* Error handling */
+irq_error:
+delete_cdev:	
+	for(i=0; i<NB_DEVICE_FILE; i++)
+	{
+        cdev_del(&c_dev[i]);
+    }
+
+destroy_device_class:
+    class_destroy(cl);
+    
+unregister_char_device:
+    unregister_chrdev_region(dev, 1);
+    
+    return ret;
 }
 
+/******************************************************************************************
+ *
+ * Function Name: rcar_hwspinlock_remove
+ *
+ * Purpose: Driver remove
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
 static int rcar_hwspinlock_remove(struct platform_device *pdev)
 {
 	int		ret;
@@ -138,6 +788,9 @@ static int rcar_hwspinlock_remove(struct platform_device *pdev)
 	return 0;
 }
 
+/***********************************************************************************************************************
+* Platform Driver structure
+***********************************************************************************************************************/
 static struct platform_driver rcar_hwspinlock_driver = {
 	.probe		= rcar_hwspinlock_probe,
 	.remove		= rcar_hwspinlock_remove,
@@ -147,6 +800,9 @@ static struct platform_driver rcar_hwspinlock_driver = {
 	},
 };
 
+/***********************************************************************************************************************
+* Initialization and De-initialization functions
+***********************************************************************************************************************/
 static int __init rcar_hwspinlock_init(void)
 {
 	return platform_driver_register(&rcar_hwspinlock_driver);
@@ -159,4 +815,7 @@ static void __exit rcar_hwspinlock_exit(void)
 }
 module_exit(rcar_hwspinlock_exit);
 
+/***********************************************************************************************************************
+* Module properties
+***********************************************************************************************************************/
 MODULE_LICENSE("GPL v2");
