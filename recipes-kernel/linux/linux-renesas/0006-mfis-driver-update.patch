diff --git a/drivers/hwspinlock/rcar_hwspinlock.c b/drivers/hwspinlock/rcar_hwspinlock.c
index 3dbfb32..bed21c2 100755
--- a/drivers/hwspinlock/rcar_hwspinlock.c
+++ b/drivers/hwspinlock/rcar_hwspinlock.c
@@ -37,6 +37,11 @@
 #include <linux/pid.h>
 #include <linux/sched.h>
 #include <linux/sched/signal.h>
+#include <linux/mm.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/fs.h> 
+#include <linux/io-mapping.h>
 #include "hwspinlock_internal.h"
 
 /******************************************************************************************
@@ -84,10 +89,10 @@
 static dev_t dev;
 static struct cdev c_dev[NB_DEVICE_FILE];
 static struct class *cl;
-
+int lock_ioctl_read; /*lock read in case of init */
 /* MFIS communication variables */
 static u32 __iomem *base_addr; /* Base address of peripheral */
-static int32_t val_read[MFIS_MSG_SIZE];
+static uint32_t val_read[MFIS_MSG_SIZE];
 static int message_received = 0;
 char cam_last_frame[NB_CAM_FILE];
 char cam_irq_count[NB_CAM_FILE];
@@ -98,6 +103,108 @@ static char wait_queue_cam_flag[NB_CAM_FILE];
 struct wait_queue_head wait_queue_config_it;
 static char wait_queue_config_flag;
 
+uint32_t address_vin_1[NB_CAM_FILE];
+uint32_t address_vin_2[NB_CAM_FILE];
+uint32_t address_vin_3[NB_CAM_FILE];
+uint32_t vin_size[NB_CAM_FILE];
+uint64_t *address_vin_virt1[NB_CAM_FILE];
+uint64_t *address_vin_virt2[NB_CAM_FILE];
+uint64_t *address_vin_virt3[NB_CAM_FILE];
+int init_done = 0;
+
+static void mfis_send_msg_config(int32_t* val);
+static void mfis_get_msg_config(void);
+static void mfis_unlock_cam_read(int cam_id, uint32_t irq_reg);
+static void mfis_clear_irq(int irq_id);
+static void mfis_handle_irq(int irq_id);
+static int mfis_check_R7_irq_state(void);
+static long mfis_config_ioctl(struct file *f, unsigned int cmd, unsigned long arg);
+static ssize_t mfis_cam_read(struct file *filep, char *buffer, size_t len, loff_t *offset);
+static int rcar_hwspinlock_trylock(struct hwspinlock *lock);
+static void rcar_hwspinlock_unlock(struct hwspinlock *lock);
+static int rcar_hwspinlock_probe(struct platform_device *pdev);
+static int rcar_hwspinlock_remove(struct platform_device *pdev);
+static int __init rcar_hwspinlock_init(void);
+static void __exit rcar_hwspinlock_exit(void);
+/******************************************************************************************
+ *
+ * Function Name: mfis_retreive_mapping
+ *
+ * Purpose:
+ *
+ * Input Parameters:     N/A
+ *
+ * Output Parameters:    N/A
+ *
+ * Comment: None
+ *
+ *******************************************************************************************/
+static int mfis_retreive_mapping(void)
+{
+    int i;
+    int32_t val_write[MFIS_MSG_SIZE];
+    lock_ioctl_read = 1;
+
+    while(mfis_check_R7_irq_state()) /* we need to wait until the irq is free, not classy but it works*/
+    {   
+    }
+
+    val_write[0]=255; /* ask the r7 to send all vin buffer address*/ 
+    /* Send message to R7 */
+    mfis_send_msg_config(val_write);
+
+
+    wait_event_interruptible(wait_queue_config_it, wait_queue_config_flag);
+    wait_queue_config_flag = 0;
+    if (message_received == 1)
+    {
+       memcpy(address_vin_1, val_read,sizeof(val_read));
+       message_received =0;
+    }
+    wait_event_interruptible(wait_queue_config_it, wait_queue_config_flag);
+    wait_queue_config_flag = 0;
+    if (message_received == 1)
+    {
+       memcpy(address_vin_2, val_read,sizeof(val_read));
+       message_received =0;
+    }
+    wait_event_interruptible(wait_queue_config_it, wait_queue_config_flag);
+    wait_queue_config_flag = 0;
+    if (message_received == 1)
+    {
+       memcpy(address_vin_3,val_read, sizeof(val_read));
+       message_received =0;
+    }
+    wait_event_interruptible(wait_queue_config_it, wait_queue_config_flag);
+    wait_queue_config_flag = 0;
+    if (message_received == 1)
+    {
+       memcpy(vin_size ,val_read, sizeof(val_read));
+       message_received = 0;
+    }
+    
+    lock_ioctl_read = 0;
+    for(i = 0; i < MFIS_MSG_SIZE; i ++)
+    {		
+	if (address_vin_1 [i] != 0) /* if we try to met a null address everything will crash*/
+	{
+           address_vin_virt1[i] =  memremap(address_vin_1[i], vin_size[i], MEMREMAP_WB);
+	}
+        if (address_vin_2 [i] != 0) 
+        {       
+    	   address_vin_virt2[i] = memremap(address_vin_2[i], vin_size[i], MEMREMAP_WB);
+	}
+	if(address_vin_3[i] != 0)
+	{
+	   address_vin_virt3[i] =memremap(address_vin_3[i], vin_size[i], MEMREMAP_WB);
+	}
+               
+	printk(KERN_DEBUG "Vin %d, physical address %llx %llx %llx, virtual address %llx %llx %llx of size %d \n", i, address_vin_1[i], address_vin_2[i], address_vin_3[i], address_vin_virt1[i], address_vin_virt2[i], address_vin_virt3[i], vin_size[i]);
+    }
+return 1;
+}
+
+
 /******************************************************************************************
  *
  * Function Name: mfis_send_msg_config
@@ -144,22 +251,23 @@ static void mfis_send_msg_config(int32_t* val)
 static void mfis_get_msg_config(void)
 {
     int i;
-	void *addr;
+    void *addr;
 
 	/* Get 8 message registers */
-    for(i=0; i<MFIS_MSG_SIZE; i++)
-    {
-        addr = (void __force *)base_addr + MFISAREMBR0_OFFSET + sizeof(u32) * i;
-        val_read[i] = (uint32_t) ioread32((void __iomem *)addr);
-    }
+    	for(i=0; i<MFIS_MSG_SIZE; i++)
+        {
+       	    addr = (void __force *)base_addr + MFISAREMBR0_OFFSET + sizeof(u32) * i;
+            val_read[i] = (uint32_t) ioread32((void __iomem *)addr);
+    	}
     
-    if(wait_queue_config_flag != -1)
-    {
-        wait_queue_config_flag = 1;
-        wake_up_interruptible(&wait_queue_config_it);
-    }
+    	if(wait_queue_config_flag != -1)
+    	{
+            wait_queue_config_flag = 1;
+            wake_up_interruptible(&wait_queue_config_it);
+    	}
     
-    message_received = 1;
+        message_received = 1;
+
 }
 
 
@@ -201,8 +309,7 @@ static void mfis_unlock_cam_read(int cam_id, uint32_t irq_reg)
  *
  *******************************************************************************************/
 static void mfis_clear_irq(int irq_id)
-{
-	void *addr;
+{	void *addr;
 
     /* Clear IRQ from R7 */
     addr = (void __force *)base_addr + MFISAREICR0_OFFSET + (sizeof(u32) * irq_id * 2);
@@ -396,17 +503,28 @@ static long mfis_config_ioctl(struct file *f, unsigned int cmd, unsigned long ar
             
             break;
         case RD_VALUE:
-            /* Wait for IRQ from R7 */
-            wait_event_interruptible(wait_queue_config_it, wait_queue_config_flag);
-            wait_queue_config_flag = 0;
-            
-            /* Send message to user space */
-            if (copy_to_user((int32_t *)arg, val_read, sizeof(val_read)))
+            if (lock_ioctl_read == 1) /* can be locked if init/mapping is on its way */
             {
                 return -EACCES;
             }
-            message_received = 0;
+            else
+            {
+                /* Wait for IRQ from R7 */
+                wait_event_interruptible(wait_queue_config_it, wait_queue_config_flag);
+                wait_queue_config_flag = 0;
             
+                /* Send message to user space */
+                if (copy_to_user((int32_t *)arg, val_read, sizeof(val_read)))
+                {
+                    return -EACCES;
+                }
+                message_received = 0;
+		if (val_read[0] == 1 && init_done == 0) /* in case of init message call retreive_mapping */
+    		{
+        		init_done = mfis_retreive_mapping();
+    		}
+
+            }
             break;
         default:
             return -EINVAL;
@@ -455,23 +573,51 @@ static ssize_t mfis_cam_read(struct file *filep, char *buffer, size_t len, loff_
     /* file iminor is used to determine wich cam file is called.
        The cam file numbers start at 0. It is defined in the probe fct */
     int cam_read_id = iminor(filep->f_inode);
-    char tx_buff[2];
-     
+    char tx_buff[len];
+    int last_frame; 
     wait_event_interruptible(wait_queue_cam_it[cam_read_id], wait_queue_cam_flag[cam_read_id]);
     wait_queue_cam_flag[cam_read_id] = 0;
-    
     /* Prepare TX buffer with last cam ID and number of IRQ since last read */
-    tx_buff[0] = cam_last_frame[cam_read_id];
-    tx_buff[1] = cam_irq_count[cam_read_id];
-    cam_irq_count[cam_read_id] = 0;
-    
-    if (copy_to_user(buffer, &tx_buff, 2))
+
+    last_frame = cam_last_frame[cam_read_id];
+
+    if (last_frame == 0)
     {
-        return -EACCES;
+	if (address_vin_virt1[cam_read_id] == 0)
+	{
+	    return -EACCES;
+	}
+	if (copy_to_user(buffer, (void *) address_vin_virt1[cam_read_id], len))
+        {
+            return -EACCES;
+        }
+    }
+    else if (last_frame == 1)
+    {        
+        if (address_vin_virt2[cam_read_id] == 0)
+        {
+            return -EACCES;
+        }
+
+	if (copy_to_user(buffer, (void *) address_vin_virt2[cam_read_id], len))
+        {
+            return -EACCES;
+        }
+    }
+    else
+    {
+        if (address_vin_virt3[cam_read_id] == 0)
+        {
+            return -EACCES;
+        }
+
+	if (copy_to_user(buffer, (void *) address_vin_virt3[cam_read_id], len))
+        {
+            return -EACCES;
+        }
     }
     return 1;
 }
-
 /***********************************************************************************************************************
 * File operations structure
 ***********************************************************************************************************************/
@@ -740,8 +886,9 @@ static int rcar_hwspinlock_probe(struct platform_device *pdev)
     }
     
     init_waitqueue_head(&wait_queue_config_it);
-    
-out:
+    /* retreive cam buffer physical values */
+
+out:     
 	return ret;
 	
 	/* Error handling */
